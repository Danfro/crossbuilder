#!/bin/sh

# Copyright 2016 Canonical Ltd.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Florian Boucault <florian.boucault@canonical.com>

 

# TODO:
# BEFORE WIDESPREAD PROMOTION
# - document commands PACKAGE parameter
# - support Debian package format 3.0 (quilt) when no upstream tarball is available (ex: libqofono)
# - support building multiple projects that depend on each other: crossbuilder PACKAGE1 PACKAGE2 PACKAGE3
# - when deploy fails indicate it did
# - do not only use username but also userid to support multiusers dev machines

# PROJECT CUSTOMISATION - FASTER
# - support per project configuration; for example post deploy rules, custom build rules, custom deploy rules
# - option to pass configure flags (DEB_CONFIGURE_EXTRA_FLAGS)

# LATER
# - devices's local apt repository in /tmp is deleted upon reboot but apt still knows about it
# - make it easy to build for multiple target archs simultaneously
# - implement a 'make install' version
# - make it faster: bypass apt update
# - check if a newer version of the container's image is available
# - option to cleanup device (undeploy)

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
LIGHT_RED='\033[1;31m'
LIGHT_GREEN='\033[1;32m'
NC='\033[0m'
ERROR_COLOR=$LIGHT_RED
POSITIVE_COLOR=$GREEN
PROGRAM_NAME=`basename $0`

display_help () {
    echo "Usage: $PROGRAM_NAME [options] [command]"
    echo ""
    echo "If no command is passed '$PROGRAM_NAME' will detect the package located in the current directory, "
    echo "create a container for it, download its dependencies, build it and deploy it to the connected device."
    echo ""
    echo "Available commands:"
    echo "    help          - Display this help."
    echo "    setup-lxd     - Setup LXD."
    echo "    new           - Create a container to build in."
    echo "    delete        - Delete a container."
#    echo "    list          - List existing containers."
    echo "    shell         - Executes a shell in a container (will create it if needed)."
    echo "    source        - Download a source package from the repositories."
    echo "    dependencies  - Download and install the dependencies of a package in a container (will create it if needed)"
    echo "    build         - Build a package in a container (will create it if needed)."
    echo "    clean         - Clean up the artifacts generated by a build."
    echo "    deploy        - Deploy built packages to a connected device."
#    echo "    undeploy      - Remove previously deployed packages from a connected device."
    echo ""
    echo "Options:"
#    echo "  --verbose       - Print verbose information."
    echo "  --packages       - Packages to deploy [by default: all the ones already installed on device]."
    echo "  --architecture   - Architecture to build for [defaults to architecture of connected device, if none then armhf]."
    echo "  --ubuntu         - Version of Ubuntu to build for [defaults to version of connected device, if none then 15.04]."
    echo "  --lxd-image      - LXD image to use [defaults to the ones provided by the Ubuntu SDK (example: ubuntu-sdk-15.04-amd64-armhf-dev)."
    echo "  --password       - User password of the device to deploy to [defaults to 0000]."
}


exec_device () {
    #echo adb shell "$@"
    adb shell "$@"
}

exec_container_root () {
    command="$@"
    #echo lxc exec $LXD_CONTAINER "$@"
    lxc exec $LXD_CONTAINER -- sh -c "$command"
}

exec_container () {
    command="$@"
    #echo lxc exec $LXD_CONTAINER "$@"
    lxc exec $LXD_CONTAINER -- su -l -c "cd $SOURCE_PATH_CONTAINER; $command" $USERNAME
}

variables () {
    if [ -z "$PACKAGES_TO_DEPLOY" ] ; then
        NEW_PACKAGE_VERSION=$PACKAGE_VERSION"local~"`date +%s`
    else
        NEW_PACKAGE_VERSION=$PACKAGE_VERSION
    fi;
    LXD_IMAGE_NO_DOT=$(echo $LXD_IMAGE | sed "s/\./-/")
    LXD_IMAGE_NO_PREFIX=$(echo $LXD_IMAGE_NO_DOT | sed "s/.*\://")
    LXD_CONTAINER=builder-$PACKAGE-$LXD_IMAGE_NO_PREFIX
    # LXD container name can only have HOST_NAME_MAX characters
    LXD_CONTAINER=$(echo $LXD_CONTAINER | cut -c 1-$((`getconf HOST_NAME_MAX` - 1)))
    USERNAME=`id --user --name`
    GROUPNAME=$USERNAME
    USERID=150000
    GROUPID=150000
    USERDIR=/home/$USERNAME
    SOURCE_REPOSITORY=$USERDIR/source_repository
    SCRIPT_DIR=`dirname $0`
    DEBS_TARBALL=built_debs.tar
    CREATE_REPO_SCRIPT=create_repository.sh
    PARALLEL_BUILD=$((`nproc` + 1))
    MOUNTED_DIRECTORY=$PWD
    MOUNT_POINT=$USERDIR/$PACKAGE
    SOURCE_PATH_LOCAL=$MOUNTED_DIRECTORY
    SOURCE_PATH_CONTAINER=$MOUNT_POINT
    POST_DEPLOY_SCRIPT=crossbuilder_post
    HOST_FARCH=$(dpkg-architecture -f -a$TARGET_ARCH -qDEB_BUILD_MULTIARCH)
    TARGET_FARCH=$(dpkg-architecture -f -a$TARGET_ARCH -qDEB_HOST_MULTIARCH)
}

check_lxd_accessible () {
    if ! lxc info > /dev/null 2>&1 ; then
        echo "${ERROR_COLOR}LXD was installed but is not accessible. Please restart your computer.${NC}"
        exit 1
    fi
}

lxd_has_image_or_container () {
    CONTAINER_COUNT=$(lxc list | wc -l)
    IMAGE_COUNT=$(lxc image list | wc -l)
    if [ $CONTAINER_COUNT = "3" ] && [ $IMAGE_COUNT = "3" ]; then
        return 1
    fi

    return 0
}

is_subuid_setup () {
    if ! grep "root:1000:1" /etc/subuid > /dev/null ; then
        return 1
    fi
    if ! grep "root:1000:1" /etc/subgid > /dev/null ; then
        return 1
    fi
    return 0
}

ensure_lxd_subuid () {
    if ! is_subuid_setup ; then
        echo "${ERROR_COLOR}LXD requires subuid to be setup adequately to mount directories in containers.${NC}"
        echo "${POSITIVE_COLOR}Would you like to do that now? (y/n) ${NC}"
        read REPLY
        echo
        if [ "$REPLY" = y ]
        then
            sudo usermod --add-subuids 1000-1000 root
            sudo usermod --add-subgids 1000-1000 root
            sudo service lxd restart
        else
            exit 1
        fi
    fi
}

setup_lxd () {
    echo "${POSITIVE_COLOR}Setting up LXD.${NC}"
    echo -n "${POSITIVE_COLOR}Would you like to setup LXD with ZFS in your home directory? (y/n) \n${NC}"
    echo -n "This is recommended for faster operation, and also in case there is not enough "
    echo -n "space in your / partition. \n"
    read REPLY
    echo
    if [ "$REPLY" = y ]
    then
        echo "${POSITIVE_COLOR}Installing ZFS.${NC}"
        sudo apt-get install -y zfsutils-linux
        LXD_POOL=~/zfs/lxd.img
        echo "${POSITIVE_COLOR}Creating file $LXD_POOL to contain all of LXD's images and containers.${NC}"
        mkdir `dirname $LXD_POOL`
        truncate -s 32G $LXD_POOL
        sudo zpool create lxd $LXD_POOL
        sudo lxd init --auto --storage-backend zfs --storage-pool lxd
        # add automatic mount of zfs pool upon boot
        echo "zpool import -c /etc/zfs/zpool.cache -aN" | sudo tee /etc/rc.local
    else
        sudo lxd init --auto
    fi
}


new_container () {
    # setup the building container
    if lxc info $LXD_CONTAINER > /dev/null 2>&1 ; then
        echo "${POSITIVE_COLOR}LXD container $LXD_CONTAINER already exists.${NC}"
        # FIXME: check if the container is already started
        lxc start $LXD_CONTAINER || true
    else
        echo "${POSITIVE_COLOR}Creating LXD container $LXD_CONTAINER using $LXD_IMAGE.${NC}"
        lxc remote --protocol=simplestreams --public=true --accept-certificate=true add sdk https://sdk-images.canonical.com || true
        lxc init $LXD_IMAGE $LXD_CONTAINER
        printf "lxc.id_map = g $GROUPID `id --group` 1\nlxc.id_map = u $USERID `id --user` 1" | lxc config set $LXD_CONTAINER raw.lxc -
        lxc start $LXD_CONTAINER
        lxc exec --env GROUPID=$GROUPID --env GROUPNAME=$GROUPNAME $LXD_CONTAINER -- addgroup --gid $GROUPID $GROUPNAME
        lxc exec --env GROUPID=$GROUPID --env USERNAME=$USERNAME --env USERID=$USERID $LXD_CONTAINER -- adduser --disabled-password --gecos "" --uid $USERID --gid $GROUPID $USERNAME
        lxc exec --env USERNAME=$USERNAME $LXD_CONTAINER -- usermod -aG sudo $USERNAME
        exec_container_root "sed -i 's/ENV_PATH.*PATH=/ENV_PATH\tPATH=\/usr\/lib\/ccache:/' /etc/login.defs"
        # FIXME: without the sleep apt update fails for lack of internet connection
        sleep 3
        exec_container_root apt install -y sudo debhelper ccache software-properties-common
        exec_container_root adduser $USERNAME sudo
        # set empty password for the user
        exec_container_root passwd --delete $USERNAME
    fi

    if ! lxc config device get $LXD_CONTAINER current_dir_mount disk ; then
        echo "${POSITIVE_COLOR}Mounting $MOUNTED_DIRECTORY in container.${NC}"
        lxc config device add $LXD_CONTAINER current_dir_mount disk source=$MOUNTED_DIRECTORY path=$MOUNT_POINT
    fi
}

delete_container () {
    echo "${POSITIVE_COLOR}Deleting LXD container $LXD_CONTAINER.${NC}"
    lxc delete -f $LXD_CONTAINER
}

shell_container () {
    echo "${POSITIVE_COLOR}Entering shell in LXD container $LXD_CONTAINER.${NC}"
    lxc exec $LXD_CONTAINER -- su --login $USERNAME
}

enable_overlay_source () {
    OVERLAY_APT="/etc/apt/sources.list.d/ci-train-ppa-service-ubuntu-stable-phone-overlay-vivid.list"
    if exec_container_root "grep '#.*deb-src' $OVERLAY_APT" ; then
        exec_container_root "sed -i 's/#.*deb-src/deb-src/' $OVERLAY_APT"
        exec_container_root apt-get update --allow-unauthenticated
    fi
}

get_source_package () {
    echo "${POSITIVE_COLOR}Downloading source package $PACKAGE for Ubuntu $TARGET_UBUNTU.${NC}"
    variables
    new_container
    enable_overlay_source
    lxc exec $LXD_CONTAINER -- su -l -c "cd $MOUNT_POINT; apt-get source $PACKAGE" $USERNAME
    PACKAGE_VERSION=`dpkg-parsechangelog --show-field Version -l $PACKAGE*/debian/changelog`
    exec_container "mv $PACKAGE*.orig.tar.* $PACKAGE*diff.* $PACKAGE*debian.tar* $PACKAGE*.dsc $USERDIR/" || true
    mv $PACKAGE-*/* .
    mv $PACKAGE-*/.[!.]* . || true
    rmdir $PACKAGE-*
    echo "${POSITIVE_COLOR}Source code for $PACKAGE is now available in $PACKAGE/.${NC}"
    VCS=$(grep -i vcs debian/control | grep --invert-match Vcs-Browser)
    if [ "$VCS" != "" ] ; then
        echo "${POSITIVE_COLOR}'$PACKAGE' packaging is versioned and available at $VCS${NC}"
    fi
}

backup_changelog () {
    exec_container cp debian/changelog /tmp/$PACKAGE-changelog.orig
}

restore_changelog () {
    exec_container mv /tmp/$PACKAGE-changelog.orig debian/changelog
}

ensure_upstream_tarball () {
    if grep quilt debian/source/format > /dev/null 2>&1 ; then
        echo "${POSITIVE_COLOR}Downloading upstream tarball of $PACKAGE in container.${NC}"
        enable_overlay_source
        exec_container "cd $USERDIR && apt-get source --download-only $PACKAGE"
    fi
}

install_dependencies () {
    exec_container [ -x debian/bileto_pre_release_hook ] && ./debian/bileto_pre_release_hook

    # install build dependencies in container
    if ! exec_container test -e $USERDIR/dependencies_installed ; then
        ensure_upstream_tarball
        echo "${POSITIVE_COLOR}Installing $TARGET_ARCH build dependencies for $PACKAGE in container $LXD_CONTAINER.${NC}"
        exec_container mkdir -p $SOURCE_REPOSITORY
        lxc file push $SCRIPT_DIR/$CREATE_REPO_SCRIPT $LXD_CONTAINER$SOURCE_REPOSITORY/
    
        backup_changelog
        trap restore_changelog HUP INT TERM QUIT
        dch -v $NEW_PACKAGE_VERSION \'\'
        if ! exec_container "dpkg-buildpackage -S -nc -d -I -Iobj-* -Idebian/tmp/* -I.bzr*" ; then
            restore_changelog
            exit 1
        fi
        exec_container "mv $USERDIR/$PACKAGE*.* $SOURCE_REPOSITORY/"
        exec_container $SOURCE_REPOSITORY/$CREATE_REPO_SCRIPT $SOURCE_REPOSITORY
        exec_container_root add-apt-repository --enable-source \"deb file://$SOURCE_REPOSITORY/ /\"
        exec_container_root "printf 'Package: *\nPin: release o=local\nPin-Priority: 2000' | sudo tee /etc/apt/preferences.d/localrepo.pref"
        exec_container_root apt-get update --allow-unauthenticated
        if ! exec_container_root apt-get build-dep -y --force-yes -a$TARGET_ARCH $PACKAGE=$NEW_PACKAGE_VERSION ; then
            restore_changelog
            exit 1
        fi

        restore_changelog

        # workaround various issues with qmake cross compilation
        # FIXME: this should be integrated in the binary package qt5-qmake-$TARGET_FARCH
        # from source package qtbase-opensource-src
        if exec_container test -e /usr/bin/qt5-qmake-$TARGET_FARCH ; then
            exec_container_root "printf '/usr/lib/$HOST_FARCH/qt5/$TARGET_FARCH/bin\n/usr/lib/$HOST_FARCH/qt5/bin\n/usr/lib/$HOST_FARCH\n' > /usr/share/qtchooser/qt5-$HOST_FARCH-$TARGET_FARCH.conf"
            exec_container_root mkdir -p /usr/lib/$HOST_FARCH/qtchooser
            exec_container_root ln -f -s ../../../share/qtchooser/qt5-$HOST_FARCH-$TARGET_FARCH.conf /usr/lib/$HOST_FARCH/qtchooser/qt5-$TARGET_FARCH.conf
            exec_container_root ln -f -s ../../../share/qtchooser/qt5-$HOST_FARCH-$TARGET_FARCH.conf /usr/lib/$HOST_FARCH/qtchooser/5-$TARGET_FARCH.conf
            exec_container_root mkdir -p /usr/lib/$HOST_FARCH/qt5/$TARGET_FARCH/bin
            exec_container_root ln -f /usr/bin/qt5-qmake-$TARGET_FARCH /usr/lib/$HOST_FARCH/qt5/$TARGET_FARCH/bin/qmake
        fi

        exec_container touch $USERDIR/dependencies_installed
    else
        echo "${POSITIVE_COLOR}$TARGET_ARCH build dependencies for $PACKAGE already installed in container $LXD_CONTAINER.${NC}"
    fi;
}

build () {
    # build package in container
    echo "${POSITIVE_COLOR}Building $PACKAGE for $TARGET_ARCH in parallel (-j$PARALLEL_BUILD).${NC}"
    exec_container "rm -f ../*.deb"
    exec_container "rm -f debian/*.debhelper.log"
    backup_changelog
    trap restore_changelog HUP INT TERM QUIT

    dch -v $NEW_PACKAGE_VERSION \'\'
    if ! exec_container "DEB_BUILD_OPTIONS='parallel=$PARALLEL_BUILD nostrip nocheck' dpkg-buildpackage -a$TARGET_ARCH -us -uc -nc -I -Iobj-* -Idebian/tmp/* -I.bzr* -b" ; then
        restore_changelog
        exit 1
    fi
    restore_changelog

    # transfer resulting debian packages to local machine
    echo "${POSITIVE_COLOR}Packing build artifacts in $DEBS_TARBALL.${NC}"
    exec_container "tar cf ../$DEBS_TARBALL ../*.deb"
    lxc file pull $LXD_CONTAINER$USERDIR/$DEBS_TARBALL .
    exec_container "rm ../*.deb ../*.changes ../$DEBS_TARBALL"
}

clean () {
    echo "${POSITIVE_COLOR}Cleaning previous build of $PACKAGE for $TARGET_ARCH.${NC}"
    exec_container debian/rules clean
}

check_for_device_network() {
    NETWORK_UP=0
    for i in `seq 1 5`
    do
        if adb shell ping -c1 -w1 google.com | grep PING > /dev/null 2>&1 ; then
            NETWORK_UP=1
            break
        fi
    done
    if [ $NETWORK_UP -ne 1 ] ; then
        echo "${ERROR_COLOR}Device connected is not connected to the Internet.${NC}"
        exit 1
    fi
}

deploy_to_device () {
    DEVICE_STATE=`adb get-state`
    if [ "$DEVICE_STATE" != "device" ] ; then
        echo "${ERROR_COLOR}No device connected to deploy to.${NC}"
        exit 1
    fi;

    # setup sudo on device
    exec_device "printf '#\041/bin/sh\necho $DEVICE_PASSWORD' >/tmp/askpass.sh"
    exec_device chmod +x /tmp/askpass.sh

    # check password is correct
    exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A touch /tmp/password_ok
    if adb pull /tmp/password_ok ; then
        rm -f password_ok
        exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A rm -f /tmp/password_ok
    else
        echo "${ERROR_COLOR}Device password incorrect. Use --password=PASSWORD to pass the correct one.${NC}"
        exit 1
    fi

    if ! test -e $DEBS_TARBALL ; then
        echo "${ERROR_COLOR}No build artifacts ($DEBS_TARBALL) to deploy to device. Run $PROGRAM_NAME build first.${NC}"
        exit 1
    fi

    echo "${POSITIVE_COLOR}Transferring build artifacts to device.${NC}"
    # tranfer debian packages to device
    exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A mount -o remount,rw /
    exec_device mkdir -p /tmp/repo
    adb push $DEBS_TARBALL /tmp/repo/
    exec_device "cd /tmp/repo && tar xvf /tmp/repo/$DEBS_TARBALL && rm -f /tmp/repo/$DEBS_TARBALL"

    # install debian packages on device
    if [ ! -z "$PACKAGES_TO_DEPLOY" ] ; then
        echo "${POSITIVE_COLOR}Installing manually specified packages:" $PACKAGES_TO_DEPLOY${NC}
        DPKG_ARGS=""
        for package in $PACKAGES_TO_DEPLOY ; do
            DPKG_ARGS="$DPKG_ARGS /tmp/repo/$package"_"$NEW_PACKAGE_VERSION"_"$TARGET_ARCH.deb"
        done
        exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A dpkg -i $DPKG_ARGS 
    else
        check_for_device_network
        echo "${POSITIVE_COLOR}Upgrading packages already installed on device with newly built ones.${NC}"
        # create local deb repository on device
        rm -f $CREATE_REPO_SCRIPT
        if ! adb pull /tmp/repo/$CREATE_REPO_SCRIPT ; then
            adb push $SCRIPT_DIR/$CREATE_REPO_SCRIPT /tmp/repo/
            exec_device /tmp/repo/$CREATE_REPO_SCRIPT /tmp/repo
            exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A add-apt-repository -y "deb file:///tmp/repo/ /"
            SERIES=$(adb shell lsb_release -cs | tr -d '\r')
            exec_device "printf 'Package: *\nPin: release o=local\nPin-Priority: 2000\n\nPackage: *\nPin: release a=$SERIES*\nPin-Priority: 50' | SUDO_ASKPASS=/tmp/askpass.sh sudo -A tee /etc/apt/preferences.d/localrepo.pref"
        else
            exec_device /tmp/repo/$CREATE_REPO_SCRIPT /tmp/repo
        fi;

        exec_device "SUDO_ASKPASS=/tmp/askpass.sh sudo -A sed -i '/Pin-Priority/c\Pin-Priority: 50' /etc/apt/preferences.d/extra-ppas.pref"
        exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A apt-get update
        exec_device SUDO_ASKPASS=/tmp/askpass.sh sudo -A apt-get dist-upgrade --yes --force-yes
        exec_device "SUDO_ASKPASS=/tmp/askpass.sh sudo -A sed -i '/Pin-Priority/c\Pin-Priority: 1001' /etc/apt/preferences.d/extra-ppas.pref"
    fi;

    # execute post deploy
    if test -e $SOURCE_PATH_LOCAL/$POST_DEPLOY_SCRIPT ; then
        echo "${POSITIVE_COLOR}Execute project specific post deploy script ($POST_DEPLOY_SCRIPT).${NC}"
        adb push $SOURCE_PATH_LOCAL/$POST_DEPLOY_SCRIPT /tmp
        exec_device sh /tmp/$POST_DEPLOY_SCRIPT
    fi
}

MISSING_PACKAGES=
if ! which dpkg > /dev/null ; then
    MISSING_PACKAGES="dpkg"
fi
if ! which dpkg-parsechangelog > /dev/null ; then
    MISSING_PACKAGES="dpkg-dev $MISSING_PACKAGES"
fi
if ! which adb > /dev/null ; then
    MISSING_PACKAGES="android-tools-adb $MISSING_PACKAGES"
fi

if [ ! -z "$MISSING_PACKAGES" ] ; then
    echo "${POSITIVE_COLOR}$PROGRAM_NAME depends on $MISSING_PACKAGES. Installing:${NC}"
    echo "sudo apt install $MISSING_PACKAGES"
    sudo apt install $MISSING_PACKAGES
fi


if ! which lxd > /dev/null ; then
    echo "${POSITIVE_COLOR}$PROGRAM_NAME uses LXD to download dependencies and build."
    echo -n "${POSITIVE_COLOR}Would you like to install LXD? (y/n) ${NC}"
    read REPLY
    echo
    if [ "$REPLY" = y ]
    then
        echo "sudo apt-get install -y lxd"
        sudo apt-get install -y lxd
#        sudo dpkg-reconfigure -p medium lxd
        setup_lxd
        ensure_lxd_subuid
        echo "${ERROR_COLOR}LXD is now setup but will only work after you restart your computer.${NC}"
        exit 0
    else
        echo "${ERROR_COLOR}$PROGRAM_NAME will not work without LXD. Bye.$OPTION${NC}"
        exit 1
    fi
fi

check_lxd_accessible
ensure_lxd_subuid

HOST_ARCH=`dpkg --print-architecture`
TARGET_ARCH=armhf
TARGET_UBUNTU=15.04
DEVICE_PASSWORD=0000

DEVICE_STATE=`adb get-state`
if [ "$DEVICE_STATE" = "device" ] ; then
    TARGET_ARCH=$(adb shell "dpkg --print-architecture" | tr -d '\r')
    TARGET_UBUNTU=$(adb shell "lsb_release --release --short" | tr -d '\r')
fi;

while [ "$1" != "" ]; do
    OPTION=`echo $1 | awk -F= '{print $1}'`
    VALUE=`echo $1 | awk -F= '{print $2}'`
    case $1 in
        -*)
            case $OPTION in
            --packages)
                PACKAGES_TO_DEPLOY=$VALUE
            ;;
            --architecture)
                TARGET_ARCH=$VALUE
            ;;
            --ubuntu)
                TARGET_UBUNTU=$VALUE
            ;;
            --lxd-image)
                LXD_IMAGE=$VALUE
            ;;
            --password)
                DEVICE_PASSWORD=$VALUE
            ;;
            *)
                display_help
                echo ""
                echo "${ERROR_COLOR}error: unknown option: $OPTION${NC}"
                exit 1
            ;;
            esac
            shift
        ;;
        *)
            break
        ;;
    esac
done

if [ -z "$LXD_IMAGE" ] ; then
    LXD_IMAGE=sdk:ubuntu-sdk-$TARGET_UBUNTU-$HOST_ARCH-$TARGET_ARCH-dev
fi

COMMAND=$1
if [ -n "$COMMAND" ] ; then
    shift
fi

if [ "$COMMAND" = "help" ] ; then
    display_help
    exit 0
fi

check_command_parameter_count() {
    MIN_PARAMETERS=$1
    MAX_PARAMETERS=$2
    COUNT=$(echo $PARAMETERS | wc -w)
    if [ $COUNT -lt $MIN_PARAMETERS ] ; then
        display_help
        echo ""
        echo "${ERROR_COLOR}Command '$COMMAND' requires a minimum of $MIN_PARAMETERS parameters. $COUNT passed.${NC}"
        exit 1
    fi
    if [ $COUNT -gt $MAX_PARAMETERS ] ; then
        display_help
        echo ""
        echo "${ERROR_COLOR}Command '$COMMAND' accepts at most $MAX_PARAMETERS parameters. $COUNT passed.${NC}"
        exit 1
    fi
}

enter_package () {
    if [ -n "$ORIGINAL_DIRECTORY" ] ; then
        cd $ORIGINAL_DIRECTORY
    fi
    ORIGINAL_DIRECTORY=$PWD
    PACKAGE=$1
    if [ -n "$PACKAGE" ] ; then
        cd $PACKAGE
    fi
}

check_changelog () {
    if test -e debian/changelog ; then
        PACKAGE=`dpkg-parsechangelog --show-field Source`
        PACKAGE_VERSION=`dpkg-parsechangelog --show-field Version`
    else
        echo "${ERROR_COLOR}No debian/changelog found in $PWD.${NC}"
        echo "If the source code is not available it can be automatically downloaded from the repositories using the 'source' command." 
        exit 1
    fi
}

if [ -z "$COMMAND" ] ; then
    check_changelog
    variables
    echo "${POSITIVE_COLOR}Building $PACKAGE for $TARGET_ARCH and deploying to device.${NC}"
    new_container
    install_dependencies
    build
    deploy_to_device
else
    PARAMETERS=$@
    case "$COMMAND" in
        setup-lxd)
            check_command_parameter_count 0 0
            if lxd_has_image_or_container ; then
                echo "${POSITIVE_COLOR}You are already using LXD. To set it up again you must delete "
                echo "all images and containers listed by 'lxc list' and 'lxc image list'.${NC}"
                return 0
            fi
            setup_lxd
        ;;
        new)
            check_command_parameter_count 0 1
            enter_package $1
            check_changelog
            variables
            new_container
        ;;
        delete)
            check_command_parameter_count 0 1
            PACKAGE=$1
            variables
            delete_container
        ;;
        shell)
            check_command_parameter_count 0 1
            enter_package $1
            check_changelog
            variables
            new_container
            shell_container
        ;;
        source)
            PACKAGE=$1
            if [ -z "$PACKAGE" ] ; then
                echo "${ERROR_COLOR}Command 'source' requires a package name: $PROGRAM_NAME source PACKAGE_NAME${NC}"
                exit 1
            fi
            check_command_parameter_count 1 1
            mkdir -p $PACKAGE
            cd $PACKAGE
            get_source_package
        ;;
        dependencies)
            check_command_parameter_count 0 1
            enter_package $1
            check_changelog
            variables
            new_container
            exec_container rm -f $USERDIR/dependencies_installed
            install_dependencies
        ;;
        build)
            check_command_parameter_count 0 1
            enter_package $1
            check_changelog
            variables
            new_container
            install_dependencies
            build
        ;;
        clean)
            check_command_parameter_count 0 1
            enter_package $1
            check_changelog
            variables
            clean
        ;;
        deploy)
            check_command_parameter_count 0 1
            enter_package $1
            check_changelog
            variables
            deploy_to_device
        ;;
        *)
            display_help
            echo ""
            echo "${ERROR_COLOR}error: unknown command: $COMMAND${NC}"
            exit 1
        ;;
    esac
fi;
